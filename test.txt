#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <pthread.h> // For multi-threading
#include <sys/mman.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "include/toolb_shm.h"

// --- Globals ---
SharedMemoryLayout* shm_ptr = NULL;
int server_fd = -1;
volatile uint64_t request_id_counter = 0;
pthread_mutex_t request_id_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t request_buffer_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t response_buffer_mutex = PTHREAD_MUTEX_INITIALIZER; // Mutex for the response buffer

// --- Function Prototypes ---
extern void http_parse_request(RequestMessage* msg, const char* request_str);
void* handle_connection(void* client_socket_ptr);

// Struct to pass arguments to worker threads
typedef struct {
    int client_socket;
    uint64_t request_id;
} thread_args_t;


void cleanup_on_signal(int signum) {
    printf("\n🛡️  [Server] Signal %d received. Shutting down...\n", signum);
    if (shm_ptr != NULL) munmap(shm_ptr, sizeof(SharedMemoryLayout));
    if (server_fd != -1) close(server_fd);
    shm_unlink(SHM_NAME);
    pthread_mutex_destroy(&request_id_mutex);
    pthread_mutex_destroy(&request_buffer_mutex);
    pthread_mutex_destroy(&response_buffer_mutex); // Destroy the new mutex
    printf("✅ [Server] Cleanup complete.\n");
    exit(0);
}

// --- Worker Thread Function ---
void* handle_connection(void* args_ptr) {
    thread_args_t* args = (thread_args_t*)args_ptr;
    int client_socket = args->client_socket;
    uint64_t request_id = args->request_id;
    free(args);

    printf("THREAD %llu: Handling new connection.\n", request_id);

    char buffer[BODY_LEN * 2] = {0};
    read(client_socket, buffer, sizeof(buffer) - 1);

    // --- CRITICAL SECTION for writing to request buffer ---
    pthread_mutex_lock(&request_buffer_mutex);
    uint32_t req_head = shm_ptr->request_buffer.head;
    // CRITICAL FIX: Use modulo for array access to prevent out-of-bounds write
    RequestMessage* msg = &shm_ptr->request_buffer.requests[req_head % REQ_BUFFER_CAPACITY];
    memset(msg, 0, sizeof(RequestMessage));
    msg->request_id = request_id;
    http_parse_request(msg, buffer);
    // Update the head pointer using modulo arithmetic to ensure it wraps.
    shm_ptr->request_buffer.head = (req_head + 1) % REQ_BUFFER_CAPACITY;
    pthread_mutex_unlock(&request_buffer_mutex);

    printf("➡️  [Thread %llu] Request sent to Python app. Path: %s\n", request_id, msg->path);

    // --- Wait for a response from Python ---
    while(1) {
        // CRITICAL SECTION for reading from response buffer
        pthread_mutex_lock(&response_buffer_mutex);

        int found_response = 0;
        if (shm_ptr->response_buffer.tail != shm_ptr->response_buffer.head) {
            // CRITICAL FIX: Use modulo for array access to prevent out-of-bounds read
            ResponseMessage* res = &shm_ptr->response_buffer.responses[shm_ptr->response_buffer.tail % RES_BUFFER_CAPACITY];
            if (res->request_id == request_id) {
                printf("⬅️  [Thread %llu] Response received. Sending to client.\n", request_id);
                char http_response[RESPONSE_LEN];
                snprintf(http_response, RESPONSE_LEN,
                         "HTTP/1.1 %d OK\r\nContent-Type: application/json\r\nContent-Length: %zu\r\n\r\n%s",
                         res->status_code, strlen(res->body), res->body);
                send(client_socket, http_response, strlen(http_response), 0);

                // Update the tail pointer using modulo arithmetic.
                shm_ptr->response_buffer.tail = (shm_ptr->response_buffer.tail + 1) % RES_BUFFER_CAPACITY;
                found_response = 1; // Mark that we found it
            }
        }

        pthread_mutex_unlock(&response_buffer_mutex);

        if (found_response) {
            break; // Exit the while loop
        }

        usleep(10000); // Poll every 10ms
    }

    close(client_socket);
    printf("THREAD %llu: Connection closed.\n", request_id);
    return NULL;
}

// --- Main (Listener) Thread ---
int main() {
    signal(SIGINT, cleanup_on_signal);

    // Setup Shared Memory
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    ftruncate(shm_fd, sizeof(SharedMemoryLayout));
    shm_ptr = (SharedMemoryLayout*)mmap(NULL, sizeof(SharedMemoryLayout), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    memset(shm_ptr, 0, sizeof(SharedMemoryLayout));
    printf("✅ [Server] Shared memory initialized.\n");

    // Setup TCP Socket Server
    struct sockaddr_in address;
    int opt = 1;
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(8080);
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 30);
    printf("✅ [Server] Listening on http://localhost:8080\n");

    while (1) {
        int client_socket = accept(server_fd, NULL, NULL);
        if (client_socket < 0) continue;

        thread_args_t* args = malloc(sizeof(thread_args_t));
        args->client_socket = client_socket;

        pthread_mutex_lock(&request_id_mutex);
        args->request_id = request_id_counter++;
        pthread_mutex_unlock(&request_id_mutex);

        pthread_t worker_thread;
        pthread_create(&worker_thread, NULL, handle_connection, (void*)args);
        pthread_detach(worker_thread);
    }
    return 0;
}


import ctypes
import mmap
import os
import sys
import time
from toolb_shm_structs import SharedMemoryLayout, REQ_BUFFER_CAPACITY, RES_BUFFER_CAPACITY, SHM_NAME

def draw_bar(label, count, capacity):
    """Creates a text-based progress bar."""
    # Ensure count is never negative for display purposes
    display_count = max(0, count)
    percentage = (display_count / capacity) if capacity > 0 else 0
    bar_length = 30
    filled_length = int(bar_length * percentage)
    bar = '█' * filled_length + '-' * (bar_length - filled_length)
    return f"{label:<18} [{bar}] {display_count}/{capacity} ({percentage:.0%})"

def main():
    """Connects to shared memory and displays buffer status."""
    libc = ctypes.CDLL("libc.so.6" if sys.platform.startswith('linux') else "libc.dylib")
    shm_open = libc.shm_open
    shm_open.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_int]
    shm_open.restype = ctypes.c_int

    # --- FIX 1: Request Read-Write access instead of Read-Only ---
    try:
        O_RDWR = os.O_RDWR
    except AttributeError:
        O_RDWR = 2 # Fallback for systems where it's not defined

    fd = shm_open(SHM_NAME.encode('utf-8'), O_RDWR, 0o666)
    if fd < 0:
        print("🔴 [Monitor] Shared memory not found. Is heartware_server running?")
        sys.exit(1)

    # --- FIX 2: Map the memory as readable AND writable ---
    with mmap.mmap(fd, ctypes.sizeof(SharedMemoryLayout), mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE) as mm:
        shm = SharedMemoryLayout.from_buffer(mm)

        while True:
            try:
                os.system('clear' if os.name != 'nt' else 'cls')

                # Use modulo arithmetic for correct count with wrapping pointers
                req_count = (shm.request_buffer.head - shm.request_buffer.tail + REQ_BUFFER_CAPACITY) % REQ_BUFFER_CAPACITY
                res_count = (shm.response_buffer.head - shm.response_buffer.tail + RES_BUFFER_CAPACITY) % RES_BUFFER_CAPACITY

                print("--- toolB Live Monitor ---")
                print(f"Time: {time.strftime('%H:%M:%S')}\n")
                print("Buffer Status:")
                print(draw_bar("Requests (C->Py)", req_count, REQ_BUFFER_CAPACITY))
                print(draw_bar("Responses (Py->C)", res_count, RES_BUFFER_CAPACITY))
                print("\nRaw Pointers:")
                print(f"Request Buffer:  Head={shm.request_buffer.head}, Tail={shm.request_buffer.tail}")
                print(f"Response Buffer: Head={shm.response_buffer.head}, Tail={shm.response_buffer.tail}")

                time.sleep(0.5)
            except KeyboardInterrupt:
                print("\n✅ [Monitor] Shutting down.")
                break

if __name__ == "__main__":
    main()


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "include/toolb_shm.h"

// Helper to find a substring and return a pointer to the character AFTER the needle.
static const char* find_after(const char* haystack, const char* needle) {
    const char* found = strstr(haystack, needle);
    if (found) {
        return found + strlen(needle);
    }
    return NULL;
}

// Helper to copy a value between a start and end pointer safely.
static void copy_value(char* dest, const char* start, const char* end, int max_len) {
    if (!start || !end || start >= end) {
        dest[0] = '\0';
        return;
    }
    int len = end - start;
    if (len >= max_len) {
        len = max_len - 1;
    }
    strncpy(dest, start, len);
    dest[len] = '\0';
}

// The C implementation of the HTTP parser.
void http_parse_request(RequestMessage* msg, const char* request_str) {
    // 1. Parse Method
    const char* method_end = strchr(request_str, ' ');
    if (!method_end) return;
    copy_value(msg->method, request_str, method_end, METHOD_LEN);

    // 2. Parse Path and Query Parameters
    const char* path_start = method_end + 1;
    const char* path_end = strchr(path_start, ' ');
    if (!path_end) return;

    const char* query_start = strchr(path_start, '?');
    if (query_start && query_start < path_end) {
        // We have query params
        copy_value(msg->path, path_start, query_start, PATH_LEN);
        copy_value(msg->query_params, query_start + 1, path_end, QUERY_PARAMS_LEN);
    } else {
        // No query params
        copy_value(msg->path, path_start, path_end, PATH_LEN);
        msg->query_params[0] = '\0';
    }

    // 3. Find and Parse Headers
    const char* content_type_start = find_after(request_str, "Content-Type: ");
    if (content_type_start) {
        const char* content_type_end = strstr(content_type_start, "\r\n");
        copy_value(msg->content_type, content_type_start, content_type_end, CONTENT_TYPE_LEN);
    }

    const char* auth_start = find_after(request_str, "Authorization: ");
    if (auth_start) {
        const char* auth_end = strstr(auth_start, "\r\n");
        copy_value(msg->authorization, auth_start, auth_end, AUTH_HEADER_LEN);
    }

    const char* len_start = find_after(request_str, "Content-Length: ");
    if (len_start) {
        msg->content_length = atoi(len_start);
    } else {
        msg->content_length = 0;
    }

    // 4. Find and Copy Body
    const char* body_start = strstr(request_str, "\r\n\r\n");
    if (body_start && msg->content_length > 0) {
        body_start += 4; // Move pointer past the double CRLF

        int len_to_copy = msg->content_length;
        if (len_to_copy >= BODY_LEN) {
            len_to_copy = BODY_LEN - 1;
        }
        strncpy(msg->body, body_start, len_to_copy);
        msg->body[len_to_copy] = '\0';
    }
}


import ctypes
import mmap
import os
import sys
import time
import json
import signal

# --- Load shared memory structures ---
from toolb_shm_structs import SharedMemoryLayout, REQ_BUFFER_CAPACITY, RES_BUFFER_CAPACITY, SHM_NAME

# --- Global flag for graceful shutdown ---
running = True

def signal_handler(signum, frame):
    """Handles Ctrl+C to allow for a graceful exit."""
    global running
    print("\n🐍 [App] Signal received. Shutting down gracefully...")
    running = False

def main():
    """Connects to shared memory and processes requests in a loop."""
    signal.signal(signal.SIGINT, signal_handler)

    # Use ctypes to call the C shm_open function for cross-platform compatibility
    libc = ctypes.CDLL("libc.so.6" if sys.platform.startswith('linux') else "libc.dylib")
    shm_open = libc.shm_open
    shm_open.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_int]
    shm_open.restype = ctypes.c_int

    try:
        O_RDWR = os.O_RDWR
    except AttributeError:
        O_RDWR = 2 # Fallback for systems where it's not defined

    fd = shm_open(SHM_NAME.encode('utf-8'), O_RDWR, 0o666)
    if fd < 0:
        print("🔴 [App] Shared memory not found. Is heartware_server running?")
        sys.exit(1)

    with mmap.mmap(fd, ctypes.sizeof(SharedMemoryLayout), mmap.MAP_SHARED, mmap.PROT_READ | mmap.PROT_WRITE) as mm:
        shm = SharedMemoryLayout.from_buffer(mm)
        req_buffer = shm.request_buffer
        res_buffer = shm.response_buffer

        print("✅ [App] Connected to shared memory. Waiting for requests...")

        while running:
            # --- Read from Request Buffer ---
            if req_buffer.tail != req_buffer.head:
                request = req_buffer.requests[req_buffer.tail]

                print(f"⬅️  [App] Received request #{request.request_id}: {request.method.decode()} {request.path.decode()}")

                # --- Write to Response Buffer ---
                res_head = res_buffer.head
                response = res_buffer.responses[res_head]
                response.request_id = request.request_id
                response.status_code = 200

                response_body = json.dumps({
                    "status": "processed by toolB_app.py",
                    "request_id": request.request_id,
                    "path_received": request.path.decode()
                })
                response.body = response_body.encode('utf-8')

                res_buffer.head = (res_head + 1) % RES_BUFFER_CAPACITY
                print(f"➡️  [App] Sent response #{response.request_id}")

                # Advance request buffer tail
                req_buffer.tail = (req_buffer.tail + 1) % REQ_BUFFER_CAPACITY
            else:
                time.sleep(0.1) # Wait if no requests

    print("✅ [App] Shutdown complete.")

if __name__ == "__main__":
    main()


import ctypes

# --- Configuration (must match C header) ---
REQ_BUFFER_CAPACITY = 16
RES_BUFFER_CAPACITY = 16
SHM_NAME = "/toolb_ipc"

METHOD_LEN = 8
PATH_LEN = 256
CONTENT_TYPE_LEN = 64
AUTH_HEADER_LEN = 256
BODY_LEN = 4096
RESPONSE_LEN = 4096

# --- Structures (must match C header) ---
class RequestMessage(ctypes.Structure):
    _fields_ = [
        ("request_id", ctypes.c_uint64),
        ("method", ctypes.c_char * METHOD_LEN),
        ("path", ctypes.c_char * PATH_LEN),
        ("content_type", ctypes.c_char * CONTENT_TYPE_LEN),
        ("authorization", ctypes.c_char * AUTH_HEADER_LEN),
        ("content_length", ctypes.c_int),
        ("body", ctypes.c_char * BODY_LEN),
    ]

class ResponseMessage(ctypes.Structure):
    _fields_ = [
        ("request_id", ctypes.c_uint64),
        ("status_code", ctypes.c_int),
        ("body", ctypes.c_char * RESPONSE_LEN),
    ]

class RequestRingBuffer(ctypes.Structure):
    _fields_ = [
        ("head", ctypes.c_uint32),
        ("tail", ctypes.c_uint32),
        ("requests", RequestMessage * REQ_BUFFER_CAPACITY),
    ]

class ResponseRingBuffer(ctypes.Structure):
    _fields_ = [
        ("head", ctypes.c_uint32),
        ("tail", ctypes.c_uint32),
        ("responses", ResponseMessage * RES_BUFFER_CAPACITY),
    ]

class SharedMemoryLayout(ctypes.Structure):
    _fields_ = [
        ("request_buffer", RequestRingBuffer),
        ("response_buffer", ResponseRingBuffer),
    ]


#ifndef TOOLB_SHM_H
#define TOOLB_SHM_H

#include <stdint.h>

// --- Configuration ---
#define REQ_BUFFER_CAPACITY 16
#define RES_BUFFER_CAPACITY 16
#define SHM_NAME "/toolb_ipc"

// --- Data Structures ---
#define METHOD_LEN 8
#define PATH_LEN 256
#define QUERY_PARAMS_LEN 256 // New field
#define CONTENT_TYPE_LEN 64
#define AUTH_HEADER_LEN 256
#define BODY_LEN 4096
#define RESPONSE_LEN 4096

// Message from C -> Python
typedef struct {
    uint64_t request_id;
    char method[METHOD_LEN];
    char path[PATH_LEN];
    char query_params[QUERY_PARAMS_LEN]; // New field
    char content_type[CONTENT_TYPE_LEN];
    char authorization[AUTH_HEADER_LEN];
    int content_length;
    char body[BODY_LEN];
} RequestMessage;

// Message from Python -> C
typedef struct {
    uint64_t request_id;
    int status_code;
    char body[RESPONSE_LEN];
} ResponseMessage;

// Ring buffer structure for requests
typedef struct {
    volatile uint32_t head;
    volatile uint32_t tail;
    RequestMessage requests[REQ_BUFFER_CAPACITY];
} RequestRingBuffer;

// Ring buffer structure for responses
typedef struct {
    volatile uint32_t head;
    volatile uint32_t tail;
    ResponseMessage responses[RES_BUFFER_CAPACITY];
} ResponseRingBuffer;

// The final, top-level shared memory object
typedef struct {
    RequestRingBuffer request_buffer;
    ResponseRingBuffer response_buffer;
} SharedMemoryLayout;

#endif // TOOLB_SHM_H


# Makefile for toolB (Concurrent C-Parser Version)

# Compiler
CC = gcc

# Flags - Added -pthread for multi-threading
CFLAGS = -Wall -Isrc/include -O2 -pthread

# Directories
BIN_DIR = bin
APP_DIR = app

# Source files
C_SOURCES = src/heartware_server.c src/c_parser.c
C_OBJS = $(C_SOURCES:.c=.o)
TARGET = $(BIN_DIR)/heartware_server

# Default target
all: $(TARGET)

# Rule to link the final executable
$(TARGET): $(C_OBJS)
	@mkdir -p $(BIN_DIR)
	$(CC) -o $(TARGET) $(C_OBJS) $(CFLAGS) # Added CFLAGS here for linking
	@echo "✅ toolB Concurrent Server compiled successfully -> $(TARGET)"

# Generic rule to compile any .c file into a .o file
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# --- Target Commands ---
run-server: all
	@echo "🚀 Starting toolB Concurrent Server..."
	@./$(TARGET)

run-app:
	@echo "🐍 Starting Python Application..."
	@python3 $(APP_DIR)/toolb_app.py

run-monitor:
	@echo "📊 Starting Live Monitor..."
	@python3 $(APP_DIR)/monitor.py

clean:
	@echo "🧹 Cleaning up..."
	@rm -f src/*.o
	@rm -rf $(BIN_DIR)
	@echo "Cleanup complete."

.PHONY: all run-server run-app clean run-monitor
